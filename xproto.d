/* this file is generated by xd/codegen.py */

module xd.xproto;

version (Posix)
{
    //import core.sys.posix.sys.uio: iovec;
}

import xd.util: iovec, pad4, bitcount;


/**
 * typedefs
 */
typedef uint Window;
typedef uint PixMap;
typedef uint Cursor;
typedef uint Font;
typedef uint GContext;
typedef uint ColorMap;
typedef uint Atom;
typedef uint Drawable;
typedef uint Fontable;
typedef uint VisualID;
typedef uint Timestamp;
typedef uint KeySym;
typedef ubyte KeyCode;
typedef ubyte Button;


/**
 * structs
 */


struct Point
{
    short x;
    short y;
}


struct Rectangle
{
    short x;
    short y;
    ushort width;
    ushort height;
}


struct Arc
{
    short x;
    short y;
    ushort width;
    ushort height;
    short angle1;
    short angle2;
}


struct Format
{
    ubyte depth;
    ubyte bits_per_pixel;
    ubyte scanline_pad;
    byte[5] _pad0;
}


struct VisualType
{
    VisualID visual_id;
    ubyte klass;
    ubyte bits_per_rgb_value;
    ushort colormap_entries;
    uint red_mask;
    uint green_mask;
    uint blue_mask;
    byte[4] _pad0;
}


struct Depth
{
    ubyte depth;
    byte[1] _pad0;
    ushort visuals_len;
    byte[4] _pad1;
    VisualType[] visuals;
}


struct Screen
{
    Window root;
    ColorMap default_colormap;
    uint white_pixel;
    uint black_pixel;
    uint current_input_masks;
    ushort width_in_pixels;
    ushort height_in_pixels;
    ushort width_in_millimeters;
    ushort height_in_millimeters;
    ushort min_installed_maps;
    ushort max_installed_maps;
    VisualID root_visual;
    ubyte backing_stores;
    ubyte save_unders;
    ubyte root_depth;
    ubyte allowed_depths_len;
    Depth[] allowed_depths;
}


struct SetupRequest
{
    ubyte byte_order;
    byte[1] _pad0;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort authorization_protocol_name_len;
    ushort authorization_protocol_data_len;
    byte[2] _pad1;
    char[] authorization_protocol_name;
    char[] authorization_protocol_data;

    iovec[6] toIOVector()
    {
        iovec[6] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.authorization_protocol_name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.authorization_protocol_name.offsetof);

        assert (this.authorization_protocol_name_len == this.authorization_protocol_name.length);
        parts[2].iov_base = this.authorization_protocol_name.ptr;
        parts[2].iov_len = this.authorization_protocol_name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.authorization_protocol_name.length * char.sizeof);

        assert (this.authorization_protocol_data_len == this.authorization_protocol_data.length);
        parts[4].iov_base = this.authorization_protocol_data.ptr;
        parts[4].iov_len = this.authorization_protocol_data.length * char.sizeof;

        parts[5].iov_base = null;
        parts[5].iov_len = pad4(this.authorization_protocol_data.length * char.sizeof);

        return parts;
    }
}


struct SetupFailed
{
    ubyte status;
    ubyte reason_len;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort length;
    char[] reason;
}


struct SetupAuthenticate
{
    ubyte status;
    byte[5] _pad0;
    ushort length;
    char[] reason;
}


struct Setup
{
    ubyte status;
    byte[1] _pad0;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort length;
    uint release_number;
    uint resource_id_base;
    uint resource_id_mask;
    uint motion_buffer_size;
    ushort vendor_len;
    ushort maximum_request_length;
    ubyte roots_len;
    ubyte pixmap_formats_len;
    ubyte image_byte_order;
    ubyte bitmap_format_bit_order;
    ubyte bitmap_format_scanline_unit;
    ubyte bitmap_format_scanline_pad;
    KeyCode min_keycode;
    KeyCode max_keycode;
    byte[4] _pad1;
    char[] vendor;
    Format[] pixmap_formats;
    Screen[] roots;

    this(const ubyte[] buf)
    {
        int offset_idx = 0;
        auto this_buf = cast(ubyte*)&this;
        this_buf[0..this.vendor.offsetof] =
                    buf[offset_idx..offset_idx+this.vendor.offsetof];
        offset_idx += this.vendor.offsetof;

        this.vendor = (cast(char*)&buf[offset_idx])[0..this.vendor_len].dup;
        offset_idx += this.vendor_len * char.sizeof;
        offset_idx += pad4(this.vendor_len * char.sizeof);

        this.pixmap_formats = (cast(Format*)&buf[offset_idx])[0..this.pixmap_formats_len].dup;
        offset_idx += this.pixmap_formats_len * Format.sizeof;
        offset_idx += pad4(this.pixmap_formats_len * Format.sizeof);

        this.roots.length = this.roots_len;
        foreach (ref screen; this.roots)
        {
            auto screen_buf = cast(ubyte*)&screen;
            screen_buf[0..screen.allowed_depths.offsetof] =
                        buf[offset_idx..offset_idx+screen.allowed_depths.offsetof];
            offset_idx += screen.allowed_depths.offsetof;

            screen.allowed_depths.length = screen.allowed_depths_len;
            foreach (ref depth; screen.allowed_depths)
            {
                auto depth_buf = cast(ubyte*)&depth;
                depth_buf[0..depth.visuals.offsetof] =
                            buf[offset_idx..offset_idx+depth.visuals.offsetof];
                offset_idx += depth.visuals.offsetof;

                depth.visuals = (cast(VisualType*)&buf[offset_idx])[0..depth.visuals_len].dup;
                offset_idx += depth.visuals_len * VisualType.sizeof;
                offset_idx += pad4(depth.visuals_len * VisualType.sizeof);
            }
        }
    }
}


struct TimeCoord
{
    Timestamp time;
    short x;
    short y;
}


struct FontProp
{
    Atom name;
    uint value;
}


struct CharInfo
{
    short left_side_bearing;
    short right_side_bearing;
    short character_width;
    short ascent;
    short descent;
    ushort attributes;
}


struct Str
{
    ubyte name_len;
    char[] name;
}


struct Segment
{
    short x1;
    short y1;
    short x2;
    short y2;
}


struct ColorItem
{
    uint pixel;
    ushort red;
    ushort green;
    ushort blue;
    ubyte flags;
    byte[1] _pad0;
}


struct RGB
{
    ushort red;
    ushort green;
    ushort blue;
    byte[2] _pad0;
}


struct Host
{
    ubyte family;
    byte[1] _pad0;
    ushort address_len;
    ubyte[] address;
}


/**
 *unions
 */


/**
 * enums
 */

enum VISUALCLASS
{
    StaticGray = 0,
    GrayScale = 1,
    StaticColor = 2,
    PseudoColor = 3,
    TrueColor = 4,
    DirectColor = 5,
}

enum EVENTMASK
{
    NoEvent = 0,
    KeyPress = 0,
    KeyRelease = 1,
    ButtonPress = 2,
    ButtonRelease = 3,
    EnterWindow = 4,
    LeaveWindow = 5,
    PointerMotion = 6,
    PointerMotionHint = 7,
    Button1Motion = 8,
    Button2Motion = 9,
    Button3Motion = 10,
    Button4Motion = 11,
    Button5Motion = 12,
    ButtonMotion = 13,
    KeymapState = 14,
    Exposure = 15,
    VisibilityChange = 16,
    StructureNotify = 17,
    ResizeRedirect = 18,
    SubstructureNotify = 19,
    SubstructureRedirect = 20,
    FocusChange = 21,
    PropertyChange = 22,
    ColorMapChange = 23,
    OwnerGrabButton = 24,
}

enum BACKINGSTORE
{
    NotUseful = 0,
    WhenMapped = 1,
    Always = 2,
}

enum IMAGEORDER
{
    LSBFirst = 0,
    MSBFirst = 1,
}

enum MODMASK
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    _1 = 3,
    _2 = 4,
    _3 = 5,
    _4 = 6,
    _5 = 7,
    Any = 15,
}

enum KEYBUTMASK
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    Mod1 = 3,
    Mod2 = 4,
    Mod3 = 5,
    Mod4 = 6,
    Mod5 = 7,
    Button1 = 8,
    Button2 = 9,
    Button3 = 10,
    Button4 = 11,
    Button5 = 12,
}

enum WINDOW
{
    None = 0,
}

enum BUTTONMASK
{
    _1 = 8,
    _2 = 9,
    _3 = 10,
    _4 = 11,
    _5 = 12,
    Any = 15,
}

enum MOTION
{
    Normal = 0,
    Hint = 1,
}

enum NOTIFYDETAIL
{
    Ancestor = 0,
    Virtual = 1,
    Inferior = 2,
    Nonlinear = 3,
    NonlinearVirtual = 4,
    Pointer = 5,
    PointerRoot = 6,
    None = 7,
}

enum NOTIFYMODE
{
    Normal = 0,
    Grab = 1,
    Ungrab = 2,
    WhileGrabbed = 3,
}

enum VISIBILITY
{
    Unobscured = 0,
    PartiallyObscured = 1,
    FullyObscured = 2,
}

enum PLACE
{
    OnTop = 0,
    OnBottom = 1,
}

enum PROPERTY
{
    NewValue = 0,
    Delete = 1,
}

enum TIME
{
    CurrentTime = 0,
}

enum ATOM
{
    None = 0,
    Any = 0,
    PRIMARY,
    SECONDARY,
    ARC,
    ATOM,
    BITMAP,
    CARDINAL,
    COLORMAP,
    CURSOR,
    CUT_BUFFER0,
    CUT_BUFFER1,
    CUT_BUFFER2,
    CUT_BUFFER3,
    CUT_BUFFER4,
    CUT_BUFFER5,
    CUT_BUFFER6,
    CUT_BUFFER7,
    DRAWABLE,
    FONT,
    INTEGER,
    PIXMAP,
    POINT,
    RECTANGLE,
    RESOURCE_MANAGER,
    RGB_COLOR_MAP,
    RGB_BEST_MAP,
    RGB_BLUE_MAP,
    RGB_DEFAULT_MAP,
    RGB_GRAY_MAP,
    RGB_GREEN_MAP,
    RGB_RED_MAP,
    STRING,
    VISUALID,
    WINDOW,
    WM_COMMAND,
    WM_HINTS,
    WM_CLIENT_MACHINE,
    WM_ICON_NAME,
    WM_ICON_SIZE,
    WM_NAME,
    WM_NORMAL_HINTS,
    WM_SIZE_HINTS,
    WM_ZOOM_HINTS,
    MIN_SPACE,
    NORM_SPACE,
    MAX_SPACE,
    END_SPACE,
    SUPERSCRIPT_X,
    SUPERSCRIPT_Y,
    SUBSCRIPT_X,
    SUBSCRIPT_Y,
    UNDERLINE_POSITION,
    UNDERLINE_THICKNESS,
    STRIKEOUT_ASCENT,
    STRIKEOUT_DESCENT,
    ITALIC_ANGLE,
    X_HEIGHT,
    QUAD_WIDTH,
    WEIGHT,
    POINT_SIZE,
    RESOLUTION,
    COPYRIGHT,
    NOTICE,
    FONT_NAME,
    FAMILY_NAME,
    FULL_NAME,
    CAP_HEIGHT,
    WM_CLASS,
    WM_TRANSIENT_FOR,
}

enum COLORMAPSTATE
{
    Uninstalled = 0,
    Installed = 1,
}

enum COLORMAP
{
    None = 0,
}

enum MAPPING
{
    Modifier = 0,
    Keyboard = 1,
    Pointer = 2,
}

enum WINDOWCLASS
{
    CopyFromParent = 0,
    InputOutput = 1,
    InputOnly = 2,
}

enum CW
{
    BackPixmap = 0,
    BackPixel = 1,
    BorderPixmap = 2,
    BorderPixel = 3,
    BitGravity = 4,
    WinGravity = 5,
    BackingStore = 6,
    BackingPlanes = 7,
    BackingPixel = 8,
    OverrideRedirect = 9,
    SaveUnder = 10,
    EventMask = 11,
    DontPropagate = 12,
    Colormap = 13,
    Cursor = 14,
}

enum BACKPIXMAP
{
    None = 0,
    ParentRelative = 1,
}

enum GRAVITY
{
    BitForget = 0,
    WinUnmap = 0,
    NorthWest = 1,
    North = 2,
    NorthEast = 3,
    West = 4,
    Center = 5,
    East = 6,
    SouthWest = 7,
    South = 8,
    SouthEast = 9,
    Static = 10,
}

enum MAPSTATE
{
    Unmapped = 0,
    Unviewable = 1,
    Viewable = 2,
}

enum SETMODE
{
    Insert = 0,
    Delete = 1,
}

enum CONFIGWINDOW
{
    X = 0,
    Y = 1,
    Width = 2,
    Height = 3,
    BorderWidth = 4,
    Sibling = 5,
    StackMode = 6,
}

enum STACKMODE
{
    Above = 0,
    Below = 1,
    TopIf = 2,
    BottomIf = 3,
    Opposite = 4,
}

enum CIRCULATE
{
    RaiseLowest = 0,
    LowerHighest = 1,
}

enum PROPMODE
{
    Replace = 0,
    Prepend = 1,
    Append = 2,
}

enum GETPROPERTYTYPE
{
    Any = 0,
}

enum SENDEVENTDEST
{
    PointerWindow = 0,
    ItemFocus = 1,
}

enum GRABMODE
{
    Sync = 0,
    Async = 1,
}

enum GRABSTATUS
{
    Success = 0,
    AlreadyGrabbed = 1,
    InvalidTime = 2,
    NotViewable = 3,
    Frozen = 4,
}

enum CURSOR
{
    None = 0,
}

enum BUTTONINDEX
{
    Any = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

enum GRAB
{
    Any = 0,
}

enum ALLOW
{
    AsyncPointer = 0,
    SyncPointer = 1,
    ReplayPointer = 2,
    AsyncKeyboard = 3,
    SyncKeyboard = 4,
    ReplayKeyboard = 5,
    AsyncBoth = 6,
    SyncBoth = 7,
}

enum INPUTFOCUS
{
    None = 0,
    PointerRoot = 1,
    Parent = 2,
    FollowKeyboard = 3,
}

enum FONTDRAW
{
    LeftToRight = 0,
    RightToLeft = 1,
}

enum GC
{
    Function = 0,
    PlaneMask = 1,
    Foreground = 2,
    Background = 3,
    LineWidth = 4,
    LineStyle = 5,
    CapStyle = 6,
    JoinStyle = 7,
    FillStyle = 8,
    FillRule = 9,
    Tile = 10,
    Stipple = 11,
    TileStippleOriginX = 12,
    TileStippleOriginY = 13,
    Font = 14,
    SubwindowMode = 15,
    GraphicsExposures = 16,
    ClipOriginX = 17,
    ClipOriginY = 18,
    ClipMask = 19,
    DashOffset = 20,
    DashList = 21,
    ArcMode = 22,
}

enum GX
{
    clear = 0,
    and = 1,
    andReverse = 2,
    copy = 3,
    andInverted = 4,
    noop = 5,
    xor = 6,
    or = 7,
    nor = 8,
    equiv = 9,
    invert = 10,
    orReverse = 11,
    copyInverted = 12,
    orInverted = 13,
    nand = 14,
    set = 15,
}

enum LINESTYLE
{
    Solid = 0,
    OnOffDash = 1,
    DoubleDash = 2,
}

enum CAPSTYLE
{
    NotLast = 0,
    Butt = 1,
    Round = 2,
    Projecting = 3,
}

enum JOINSTYLE
{
    Miter = 0,
    Round = 1,
    Bevel = 2,
}

enum FILLSTYLE
{
    Solid = 0,
    Tiled = 1,
    Stippled = 2,
    OpaqueStippled = 3,
}

enum FILLRULE
{
    EvenOdd = 0,
    Winding = 1,
}

enum SUBWINDOWMODE
{
    ClipByChildren = 0,
    IncludeInferiors = 1,
}

enum ARCMODE
{
    Chord = 0,
    PieSlice = 1,
}

enum CLIPORDERING
{
    Unsorted = 0,
    YSorted = 1,
    YXSorted = 2,
    YXBanded = 3,
}

enum COORDMODE
{
    Origin = 0,
    Previous = 1,
}

enum POLYSHAPE
{
    Complex = 0,
    Nonconvex = 1,
    Convex = 2,
}

enum IMAGEFORMAT
{
    XYBitmap = 0,
    XYPixmap = 1,
    ZPixmap = 2,
}

enum COLORMAPALLOC
{
    None = 0,
    All = 1,
}

enum COLORFLAG
{
    Red = 0,
    Green = 1,
    Blue = 2,
}

enum PIXMAP
{
    None = 0,
}

enum FONT
{
    None = 0,
}

enum QUERYSHAPEOF
{
    LargestCursor = 0,
    FastestTile = 1,
    FastestStipple = 2,
}

enum KB
{
    KeyClickPercent = 0,
    BellPercent = 1,
    BellPitch = 2,
    BellDuration = 3,
    Led = 4,
    LedMode = 5,
    Key = 6,
    AutoRepeatMode = 7,
}

enum LEDMODE
{
    Off = 0,
    On = 1,
}

enum AUTOREPEATMODE
{
    Off = 0,
    On = 1,
    Default = 2,
}

enum BLANKING
{
    NotPreferred = 0,
    Preferred = 1,
    Default = 2,
}

enum EXPOSURES
{
    NotAllowed = 0,
    Allowed = 1,
    Default = 2,
}

enum HOSTMODE
{
    Insert = 0,
    Delete = 1,
}

enum FAMILY
{
    Internet = 0,
    DECnet = 1,
    Chaos = 2,
    ServerInterpreted = 5,
    Internet6 = 6,
}

enum ACCESSCONTROL
{
    Disable = 0,
    Enable = 1,
}

enum CLOSEDOWN
{
    DestroyAll = 0,
    RetainPermanent = 1,
    RetainTemporary = 2,
}

enum KILL
{
    AllTemporary = 0,
}

enum SCREENSAVER
{
    Reset = 0,
    Active = 1,
}

enum MAPPINGSTATUS
{
    Success = 0,
    Busy = 1,
    Failure = 2,
}

enum MAPINDEX
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    _1 = 3,
    _2 = 4,
    _3 = 5,
    _4 = 6,
    _5 = 7,
}


/**
 * requests
 */


struct CreateWindow
{
    ubyte depth;
    Window wid;
    Window parent;
    short x;
    short y;
    ushort width;
    ushort height;
    ushort border_width;
    ushort klass;
    VisualID visual;
    uint value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct ChangeWindowAttributes
{
    byte[1] _pad0;
    Window window;
    uint value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct GetWindowAttributes
{
    byte[1] _pad0;
    Window window;

    struct Reply
    {
        ubyte backing_store;
        VisualID visual;
        ushort klass;
        ubyte bit_gravity;
        ubyte win_gravity;
        uint backing_planes;
        uint backing_pixel;
        ubyte save_under;
        ubyte map_is_installed;
        ubyte map_state;
        ubyte override_redirect;
        ColorMap colormap;
        uint all_event_masks;
        uint your_event_mask;
        ushort do_not_propagate_mask;
        byte[2] _pad0;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct DestroyWindow
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct DestroySubwindows
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeSaveSet
{
    ubyte mode;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ReparentWindow
{
    byte[1] _pad0;
    Window window;
    Window parent;
    short x;
    short y;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct MapWindow
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct MapSubwindows
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UnmapWindow
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UnmapSubwindows
{
    byte[1] _pad0;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ConfigureWindow
{
    byte[1] _pad0;
    Window window;
    ushort value_mask;
    byte[2] _pad1;
    //ushort value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct CirculateWindow
{
    ubyte direction;
    Window window;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetGeometry
{
    byte[1] _pad0;
    Drawable drawable;

    struct Reply
    {
        ubyte depth;
        Window root;
        short x;
        short y;
        ushort width;
        ushort height;
        ushort border_width;
        byte[2] _pad0;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryTree
{
    byte[1] _pad0;
    Window window;

    struct Reply
    {
        byte[1] _pad0;
        Window root;
        Window parent;
        ushort children_len;
        byte[14] _pad1;
        Window[] children;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.children.offsetof] =
                        buf[offset_idx..offset_idx+this.children.offsetof];
            offset_idx += this.children.offsetof;

            this.children = (cast(Window*)&buf[offset_idx])[0..this.children_len].dup;
            offset_idx += this.children_len * Window.sizeof;
            offset_idx += pad4(this.children_len * Window.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct InternAtom
{
    ubyte only_if_exists;
    ushort name_len;
    byte[2] _pad0;
    char[] name;

    struct Reply
    {
        byte[1] _pad0;
        Atom atom;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct GetAtomName
{
    byte[1] _pad0;
    Atom atom;

    struct Reply
    {
        byte[1] _pad0;
        ushort name_len;
        byte[22] _pad1;
        char[] name;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.name.offsetof] =
                        buf[offset_idx..offset_idx+this.name.offsetof];
            offset_idx += this.name.offsetof;

            this.name = (cast(char*)&buf[offset_idx])[0..this.name_len].dup;
            offset_idx += this.name_len * char.sizeof;
            offset_idx += pad4(this.name_len * char.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeProperty
{
    ubyte mode;
    Window window;
    Atom property;
    Atom type;
    ubyte format;
    byte[3] _pad0;
    uint data_len;
    void[] data;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.data.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.data.offsetof);

        assert (((this.data_len * this.format) / 8) == this.data.length);
        parts[2].iov_base = this.data.ptr;
        parts[2].iov_len = this.data.length * void.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.data.length * void.sizeof);

        return parts;
    }
}


struct DeleteProperty
{
    byte[1] _pad0;
    Window window;
    Atom property;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetProperty
{
    ubyte del;
    Window window;
    Atom property;
    Atom type;
    uint long_offset;
    uint long_length;

    struct Reply
    {
        ubyte format;
        Atom type;
        uint bytes_after;
        uint value_len;
        byte[12] _pad0;
        void[] value;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.value.offsetof] =
                        buf[offset_idx..offset_idx+this.value.offsetof];
            offset_idx += this.value.offsetof;

            this.value = (cast(void*)&buf[offset_idx])[0..(this.value_len * (this.format / 8))].dup;
            offset_idx += (this.value_len * (this.format / 8)) * void.sizeof;
            offset_idx += pad4((this.value_len * (this.format / 8)) * void.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ListProperties
{
    byte[1] _pad0;
    Window window;

    struct Reply
    {
        byte[1] _pad0;
        ushort atoms_len;
        byte[22] _pad1;
        Atom[] atoms;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.atoms.offsetof] =
                        buf[offset_idx..offset_idx+this.atoms.offsetof];
            offset_idx += this.atoms.offsetof;

            this.atoms = (cast(Atom*)&buf[offset_idx])[0..this.atoms_len].dup;
            offset_idx += this.atoms_len * Atom.sizeof;
            offset_idx += pad4(this.atoms_len * Atom.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetSelectionOwner
{
    byte[1] _pad0;
    Window owner;
    Atom selection;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetSelectionOwner
{
    byte[1] _pad0;
    Atom selection;

    struct Reply
    {
        byte[1] _pad0;
        Window owner;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ConvertSelection
{
    byte[1] _pad0;
    Window requestor;
    Atom selection;
    Atom target;
    Atom property;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SendEvent
{
    ubyte propagate;
    Window destination;
    uint event_mask;
    char[32] event;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.event.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.event.offsetof);

        assert (32 == this.event.length);
        parts[2].iov_base = this.event.ptr;
        parts[2].iov_len = this.event.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.event.length * char.sizeof);

        return parts;
    }
}


struct GrabPointer
{
    ubyte owner_events;
    Window grab_window;
    ushort event_mask;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    Window confine_to;
    Cursor cursor;
    Timestamp time;

    struct Reply
    {
        ubyte status;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UngrabPointer
{
    byte[1] _pad0;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GrabButton
{
    ubyte owner_events;
    Window grab_window;
    ushort event_mask;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    Window confine_to;
    Cursor cursor;
    ubyte button;
    byte[1] _pad0;
    ushort modifiers;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UngrabButton
{
    ubyte button;
    Window grab_window;
    ushort modifiers;
    byte[2] _pad0;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeActivePointerGrab
{
    byte[1] _pad0;
    Cursor cursor;
    Timestamp time;
    ushort event_mask;
    byte[2] _pad1;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GrabKeyboard
{
    ubyte owner_events;
    Window grab_window;
    Timestamp time;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    byte[2] _pad0;

    struct Reply
    {
        ubyte status;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UngrabKeyboard
{
    byte[1] _pad0;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GrabKey
{
    ubyte owner_events;
    Window grab_window;
    ushort modifiers;
    KeyCode key;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    byte[3] _pad0;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UngrabKey
{
    KeyCode key;
    Window grab_window;
    ushort modifiers;
    byte[2] _pad0;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct AllowEvents
{
    ubyte mode;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GrabServer
{

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UngrabServer
{

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryPointer
{
    byte[1] _pad0;
    Window window;

    struct Reply
    {
        ubyte same_screen;
        Window root;
        Window child;
        short root_x;
        short root_y;
        short win_x;
        short win_y;
        ushort mask;
        byte[2] _pad0;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetMotionEvents
{
    byte[1] _pad0;
    Window window;
    Timestamp start;
    Timestamp stop;

    struct Reply
    {
        byte[1] _pad0;
        uint events_len;
        byte[20] _pad1;
        TimeCoord[] events;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.events.offsetof] =
                        buf[offset_idx..offset_idx+this.events.offsetof];
            offset_idx += this.events.offsetof;

            this.events = (cast(TimeCoord*)&buf[offset_idx])[0..this.events_len].dup;
            offset_idx += this.events_len * TimeCoord.sizeof;
            offset_idx += pad4(this.events_len * TimeCoord.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct TranslateCoordinates
{
    byte[1] _pad0;
    Window src_window;
    Window dst_window;
    short src_x;
    short src_y;

    struct Reply
    {
        ubyte same_screen;
        Window child;
        ushort dst_x;
        ushort dst_y;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct WarpPointer
{
    byte[1] _pad0;
    Window src_window;
    Window dst_window;
    short src_x;
    short src_y;
    ushort src_width;
    ushort src_height;
    short dst_x;
    short dst_y;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetInputFocus
{
    ubyte revert_to;
    Window focus;
    Timestamp time;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetInputFocus
{

    struct Reply
    {
        ubyte revert_to;
        Window focus;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryKeymap
{

    struct Reply
    {
        byte[1] _pad0;
        ubyte[32] keys;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.keys.offsetof] =
                        buf[offset_idx..offset_idx+this.keys.offsetof];
            offset_idx += this.keys.offsetof;

            this.keys = (cast(ubyte*)&buf[offset_idx])[0..32].dup;
            offset_idx += 32 * ubyte.sizeof;
            offset_idx += pad4(32 * ubyte.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct OpenFont
{
    byte[1] _pad0;
    Font fid;
    ushort name_len;
    byte[2] _pad1;
    char[] name;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct CloseFont
{
    byte[1] _pad0;
    Font font;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryFont
{
    byte[1] _pad0;
    Fontable font;

    struct Reply
    {
        byte[1] _pad0;
        CharInfo min_bounds;
        byte[4] _pad1;
        CharInfo max_bounds;
        byte[4] _pad2;
        ushort min_char_or_byte2;
        ushort max_char_or_byte2;
        ushort default_char;
        ushort properties_len;
        ubyte draw_direction;
        ubyte min_byte1;
        ubyte max_byte1;
        ubyte all_chars_exist;
        short font_ascent;
        short font_descent;
        uint char_infos_len;
        FontProp[] properties;
        CharInfo[] char_infos;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.properties.offsetof] =
                        buf[offset_idx..offset_idx+this.properties.offsetof];
            offset_idx += this.properties.offsetof;

            this.properties = (cast(FontProp*)&buf[offset_idx])[0..this.properties_len].dup;
            offset_idx += this.properties_len * FontProp.sizeof;
            offset_idx += pad4(this.properties_len * FontProp.sizeof);

            this.char_infos = (cast(CharInfo*)&buf[offset_idx])[0..this.char_infos_len].dup;
            offset_idx += this.char_infos_len * CharInfo.sizeof;
            offset_idx += pad4(this.char_infos_len * CharInfo.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryTextExtents
{
    ubyte odd_length;
    Fontable font;
    wchar[] string;

    struct Reply
    {
        ubyte draw_direction;
        short font_ascent;
        short font_descent;
        short overall_ascent;
        short overall_descent;
        int overall_width;
        int overall_left;
        int overall_right;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.string.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.string.offsetof);

        parts[2].iov_base = this.string.ptr;
        parts[2].iov_len = this.string.length * wchar.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.string.length * wchar.sizeof);

        // TODO: explain this
        this.odd_length = (this.string.length & 1);

        return parts;
    }
}


struct ListFonts
{
    byte[1] _pad0;
    ushort max_names;
    ushort pattern_len;
    char[] pattern;

    struct Reply
    {
        byte[1] _pad0;
        ushort names_len;
        byte[22] _pad1;
        Str[] names;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.names.offsetof] =
                        buf[offset_idx..offset_idx+this.names.offsetof];
            offset_idx += this.names.offsetof;

            this.names.length = this.names_len;
            foreach (ref str; this.names)
            {
                auto str_buf = cast(ubyte*)&str;
                str_buf[0..str.name.offsetof] =
                            buf[offset_idx..offset_idx+str.name.offsetof];
                offset_idx += str.name.offsetof;

                str.name = (cast(char*)&buf[offset_idx])[0..str.name_len].dup;
                offset_idx += str.name_len * char.sizeof;
                offset_idx += pad4(str.name_len * char.sizeof);
            }
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.pattern.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.pattern.offsetof);

        assert (this.pattern_len == this.pattern.length);
        parts[2].iov_base = this.pattern.ptr;
        parts[2].iov_len = this.pattern.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.pattern.length * char.sizeof);

        return parts;
    }
}


struct ListFontsWithInfo
{
    byte[1] _pad0;
    ushort max_names;
    ushort pattern_len;
    char[] pattern;

    struct Reply
    {
        ubyte name_len;
        CharInfo min_bounds;
        byte[4] _pad0;
        CharInfo max_bounds;
        byte[4] _pad1;
        ushort min_char_or_byte2;
        ushort max_char_or_byte2;
        ushort default_char;
        ushort properties_len;
        ubyte draw_direction;
        ubyte min_byte1;
        ubyte max_byte1;
        ubyte all_chars_exist;
        short font_ascent;
        short font_descent;
        uint replies_hint;
        FontProp[] properties;
        char[] name;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.properties.offsetof] =
                        buf[offset_idx..offset_idx+this.properties.offsetof];
            offset_idx += this.properties.offsetof;

            this.properties = (cast(FontProp*)&buf[offset_idx])[0..this.properties_len].dup;
            offset_idx += this.properties_len * FontProp.sizeof;
            offset_idx += pad4(this.properties_len * FontProp.sizeof);

            this.name = (cast(char*)&buf[offset_idx])[0..this.name_len].dup;
            offset_idx += this.name_len * char.sizeof;
            offset_idx += pad4(this.name_len * char.sizeof);
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.pattern.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.pattern.offsetof);

        assert (this.pattern_len == this.pattern.length);
        parts[2].iov_base = this.pattern.ptr;
        parts[2].iov_len = this.pattern.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.pattern.length * char.sizeof);

        return parts;
    }
}


struct SetFontPath
{
    byte[1] _pad0;
    ushort font_qty;
    char[] path;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.path.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.path.offsetof);

        parts[2].iov_base = this.path.ptr;
        parts[2].iov_len = this.path.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.path.length * char.sizeof);

        return parts;
    }
}


struct GetFontPath
{

    struct Reply
    {
        byte[1] _pad0;
        ushort path_len;
        byte[22] _pad1;
        Str[] path;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.path.offsetof] =
                        buf[offset_idx..offset_idx+this.path.offsetof];
            offset_idx += this.path.offsetof;

            this.path.length = this.path_len;
            foreach (ref str; this.path)
            {
                auto str_buf = cast(ubyte*)&str;
                str_buf[0..str.name.offsetof] =
                            buf[offset_idx..offset_idx+str.name.offsetof];
                offset_idx += str.name.offsetof;

                str.name = (cast(char*)&buf[offset_idx])[0..str.name_len].dup;
                offset_idx += str.name_len * char.sizeof;
                offset_idx += pad4(str.name_len * char.sizeof);
            }
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CreatePixmap
{
    ubyte depth;
    PixMap pid;
    Drawable drawable;
    ushort width;
    ushort height;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct FreePixmap
{
    byte[1] _pad0;
    PixMap pixmap;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CreateGC
{
    byte[1] _pad0;
    GContext cid;
    Drawable drawable;
    uint value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct ChangeGC
{
    byte[1] _pad0;
    GContext gc;
    uint value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct CopyGC
{
    byte[1] _pad0;
    GContext src_gc;
    GContext dst_gc;
    uint value_mask;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetDashes
{
    byte[1] _pad0;
    GContext gc;
    ushort dash_offset;
    ushort dashes_len;
    ubyte[] dashes;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.dashes.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.dashes.offsetof);

        assert (this.dashes_len == this.dashes.length);
        parts[2].iov_base = this.dashes.ptr;
        parts[2].iov_len = this.dashes.length * ubyte.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.dashes.length * ubyte.sizeof);

        return parts;
    }
}


struct SetClipRectangles
{
    ubyte ordering;
    GContext gc;
    short clip_x_origin;
    short clip_y_origin;
    Rectangle[] rectangles;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.rectangles.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.rectangles.offsetof);

        parts[2].iov_base = this.rectangles.ptr;
        parts[2].iov_len = this.rectangles.length * Rectangle.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.rectangles.length * Rectangle.sizeof);

        return parts;
    }
}


struct FreeGC
{
    byte[1] _pad0;
    GContext gc;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ClearArea
{
    ubyte exposures;
    Window window;
    short x;
    short y;
    ushort width;
    ushort height;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CopyArea
{
    byte[1] _pad0;
    Drawable src_drawable;
    Drawable dst_drawable;
    GContext gc;
    short src_x;
    short src_y;
    short dst_x;
    short dst_y;
    ushort width;
    ushort height;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CopyPlane
{
    byte[1] _pad0;
    Drawable src_drawable;
    Drawable dst_drawable;
    GContext gc;
    short src_x;
    short src_y;
    short dst_x;
    short dst_y;
    ushort width;
    ushort height;
    uint bit_plane;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct PolyPoint
{
    ubyte coordinate_mode;
    Drawable drawable;
    GContext gc;
    Point[] points;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.points.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.points.offsetof);

        parts[2].iov_base = this.points.ptr;
        parts[2].iov_len = this.points.length * Point.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.points.length * Point.sizeof);

        return parts;
    }
}


struct PolyLine
{
    ubyte coordinate_mode;
    Drawable drawable;
    GContext gc;
    Point[] points;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.points.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.points.offsetof);

        parts[2].iov_base = this.points.ptr;
        parts[2].iov_len = this.points.length * Point.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.points.length * Point.sizeof);

        return parts;
    }
}


struct PolySegment
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Segment[] segments;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.segments.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.segments.offsetof);

        parts[2].iov_base = this.segments.ptr;
        parts[2].iov_len = this.segments.length * Segment.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.segments.length * Segment.sizeof);

        return parts;
    }
}


struct PolyRectangle
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Rectangle[] rectangles;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.rectangles.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.rectangles.offsetof);

        parts[2].iov_base = this.rectangles.ptr;
        parts[2].iov_len = this.rectangles.length * Rectangle.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.rectangles.length * Rectangle.sizeof);

        return parts;
    }
}


struct PolyArc
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Arc[] arcs;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.arcs.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.arcs.offsetof);

        parts[2].iov_base = this.arcs.ptr;
        parts[2].iov_len = this.arcs.length * Arc.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.arcs.length * Arc.sizeof);

        return parts;
    }
}


struct FillPoly
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    ubyte shape;
    ubyte coordinate_mode;
    byte[2] _pad1;
    Point[] points;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.points.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.points.offsetof);

        parts[2].iov_base = this.points.ptr;
        parts[2].iov_len = this.points.length * Point.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.points.length * Point.sizeof);

        return parts;
    }
}


struct PolyFillRectangle
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Rectangle[] rectangles;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.rectangles.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.rectangles.offsetof);

        parts[2].iov_base = this.rectangles.ptr;
        parts[2].iov_len = this.rectangles.length * Rectangle.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.rectangles.length * Rectangle.sizeof);

        return parts;
    }
}


struct PolyFillArc
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Arc[] arcs;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.arcs.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.arcs.offsetof);

        parts[2].iov_base = this.arcs.ptr;
        parts[2].iov_len = this.arcs.length * Arc.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.arcs.length * Arc.sizeof);

        return parts;
    }
}


struct PutImage
{
    ubyte format;
    Drawable drawable;
    GContext gc;
    ushort width;
    ushort height;
    short dst_x;
    short dst_y;
    ubyte left_pad;
    ubyte depth;
    byte[2] _pad0;
    ubyte[] data;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.data.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.data.offsetof);

        parts[2].iov_base = this.data.ptr;
        parts[2].iov_len = this.data.length * ubyte.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.data.length * ubyte.sizeof);

        return parts;
    }
}


struct GetImage
{
    ubyte format;
    Drawable drawable;
    short x;
    short y;
    ushort width;
    ushort height;
    uint plane_mask;

    struct Reply
    {
        ubyte depth;
		ushort length;
        VisualID visual;
        byte[20] _pad0;
        ubyte[] data;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.data.offsetof] =
                        buf[offset_idx..offset_idx+this.data.offsetof];
            offset_idx += this.data.offsetof;

            this.data = (cast(ubyte*)&buf[offset_idx])[0..(this.length * 4)].dup;
            offset_idx += (this.length * 4) * ubyte.sizeof;
            offset_idx += pad4((this.length * 4) * ubyte.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct PolyText8
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    ubyte[] items;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.items.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.items.offsetof);

        parts[2].iov_base = this.items.ptr;
        parts[2].iov_len = this.items.length * ubyte.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.items.length * ubyte.sizeof);

        return parts;
    }
}


struct PolyText16
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    ubyte[] items;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.items.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.items.offsetof);

        parts[2].iov_base = this.items.ptr;
        parts[2].iov_len = this.items.length * ubyte.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.items.length * ubyte.sizeof);

        return parts;
    }
}


struct ImageText8
{
    ubyte string_len;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    char[] string;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.string.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.string.offsetof);

        assert (this.string_len == this.string.length);
        parts[2].iov_base = this.string.ptr;
        parts[2].iov_len = this.string.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.string.length * char.sizeof);

        return parts;
    }
}


struct ImageText16
{
    ubyte string_len;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    wchar[] string;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.string.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.string.offsetof);

        assert (this.string_len == this.string.length);
        parts[2].iov_base = this.string.ptr;
        parts[2].iov_len = this.string.length * wchar.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.string.length * wchar.sizeof);

        return parts;
    }
}


struct CreateColormap
{
    ubyte alloc;
    ColorMap mid;
    Window window;
    VisualID visual;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct FreeColormap
{
    byte[1] _pad0;
    ColorMap cmap;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CopyColormapAndFree
{
    byte[1] _pad0;
    ColorMap mid;
    ColorMap src_cmap;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct InstallColormap
{
    byte[1] _pad0;
    ColorMap cmap;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct UninstallColormap
{
    byte[1] _pad0;
    ColorMap cmap;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ListInstalledColormaps
{
    byte[1] _pad0;
    Window window;

    struct Reply
    {
        byte[1] _pad0;
        ushort cmaps_len;
        byte[22] _pad1;
        ColorMap[] cmaps;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.cmaps.offsetof] =
                        buf[offset_idx..offset_idx+this.cmaps.offsetof];
            offset_idx += this.cmaps.offsetof;

            this.cmaps = (cast(ColorMap*)&buf[offset_idx])[0..this.cmaps_len].dup;
            offset_idx += this.cmaps_len * ColorMap.sizeof;
            offset_idx += pad4(this.cmaps_len * ColorMap.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct AllocColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort red;
    ushort green;
    ushort blue;
    byte[2] _pad1;

    struct Reply
    {
        byte[1] _pad0;
        ushort red;
        ushort green;
        ushort blue;
        byte[2] _pad1;
        uint pixel;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct AllocNamedColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort name_len;
    byte[2] _pad1;
    char[] name;

    struct Reply
    {
        byte[1] _pad0;
        uint pixel;
        ushort exact_red;
        ushort exact_green;
        ushort exact_blue;
        ushort visual_red;
        ushort visual_green;
        ushort visual_blue;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct AllocColorCells
{
    ubyte contiguous;
    ColorMap cmap;
    ushort colors;
    ushort planes;

    struct Reply
    {
        byte[1] _pad0;
        ushort pixels_len;
        ushort masks_len;
        byte[20] _pad1;
        uint[] pixels;
        uint[] masks;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.pixels.offsetof] =
                        buf[offset_idx..offset_idx+this.pixels.offsetof];
            offset_idx += this.pixels.offsetof;

            this.pixels = (cast(uint*)&buf[offset_idx])[0..this.pixels_len].dup;
            offset_idx += this.pixels_len * uint.sizeof;
            offset_idx += pad4(this.pixels_len * uint.sizeof);

            this.masks = (cast(uint*)&buf[offset_idx])[0..this.masks_len].dup;
            offset_idx += this.masks_len * uint.sizeof;
            offset_idx += pad4(this.masks_len * uint.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct AllocColorPlanes
{
    ubyte contiguous;
    ColorMap cmap;
    ushort colors;
    ushort reds;
    ushort greens;
    ushort blues;

    struct Reply
    {
        byte[1] _pad0;
        ushort pixels_len;
        byte[2] _pad1;
        uint red_mask;
        uint green_mask;
        uint blue_mask;
        byte[8] _pad2;
        uint[] pixels;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.pixels.offsetof] =
                        buf[offset_idx..offset_idx+this.pixels.offsetof];
            offset_idx += this.pixels.offsetof;

            this.pixels = (cast(uint*)&buf[offset_idx])[0..this.pixels_len].dup;
            offset_idx += this.pixels_len * uint.sizeof;
            offset_idx += pad4(this.pixels_len * uint.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct FreeColors
{
    byte[1] _pad0;
    ColorMap cmap;
    uint plane_mask;
    uint[] pixels;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.pixels.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.pixels.offsetof);

        parts[2].iov_base = this.pixels.ptr;
        parts[2].iov_len = this.pixels.length * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.pixels.length * uint.sizeof);

        return parts;
    }
}


struct StoreColors
{
    byte[1] _pad0;
    ColorMap cmap;
    ColorItem[] items;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.items.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.items.offsetof);

        parts[2].iov_base = this.items.ptr;
        parts[2].iov_len = this.items.length * ColorItem.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.items.length * ColorItem.sizeof);

        return parts;
    }
}


struct StoreNamedColor
{
    ubyte flags;
    ColorMap cmap;
    uint pixel;
    ushort name_len;
    byte[2] _pad0;
    char[] name;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct QueryColors
{
    byte[1] _pad0;
    ColorMap cmap;
    uint[] pixels;

    struct Reply
    {
        byte[1] _pad0;
        ushort colors_len;
        byte[22] _pad1;
        RGB[] colors;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.colors.offsetof] =
                        buf[offset_idx..offset_idx+this.colors.offsetof];
            offset_idx += this.colors.offsetof;

            this.colors = (cast(RGB*)&buf[offset_idx])[0..this.colors_len].dup;
            offset_idx += this.colors_len * RGB.sizeof;
            offset_idx += pad4(this.colors_len * RGB.sizeof);
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.pixels.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.pixels.offsetof);

        parts[2].iov_base = this.pixels.ptr;
        parts[2].iov_len = this.pixels.length * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.pixels.length * uint.sizeof);

        return parts;
    }
}


struct LookupColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort name_len;
    byte[2] _pad1;
    char[] name;

    struct Reply
    {
        byte[1] _pad0;
        ushort exact_red;
        ushort exact_green;
        ushort exact_blue;
        ushort visual_red;
        ushort visual_green;
        ushort visual_blue;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct CreateCursor
{
    byte[1] _pad0;
    Cursor cid;
    PixMap source;
    PixMap mask;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;
    ushort x;
    ushort y;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct CreateGlyphCursor
{
    byte[1] _pad0;
    Cursor cid;
    Font source_font;
    Font mask_font;
    ushort source_char;
    ushort mask_char;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct FreeCursor
{
    byte[1] _pad0;
    Cursor cursor;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct RecolorCursor
{
    byte[1] _pad0;
    Cursor cursor;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryBestSize
{
    ubyte klass;
    Drawable drawable;
    ushort width;
    ushort height;

    struct Reply
    {
        byte[1] _pad0;
        ushort width;
        ushort height;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct QueryExtension
{
    byte[1] _pad0;
    ushort name_len;
    byte[2] _pad1;
    char[] name;

    struct Reply
    {
        byte[1] _pad0;
        ubyte present;
        ubyte major_opcode;
        ubyte first_event;
        ubyte first_error;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.name.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.name.offsetof);

        assert (this.name_len == this.name.length);
        parts[2].iov_base = this.name.ptr;
        parts[2].iov_len = this.name.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.name.length * char.sizeof);

        return parts;
    }
}


struct ListExtensions
{

    struct Reply
    {
        ubyte names_len;
        byte[24] _pad0;
        Str[] names;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.names.offsetof] =
                        buf[offset_idx..offset_idx+this.names.offsetof];
            offset_idx += this.names.offsetof;

            this.names.length = this.names_len;
            foreach (ref str; this.names)
            {
                auto str_buf = cast(ubyte*)&str;
                str_buf[0..str.name.offsetof] =
                            buf[offset_idx..offset_idx+str.name.offsetof];
                offset_idx += str.name.offsetof;

                str.name = (cast(char*)&buf[offset_idx])[0..str.name_len].dup;
                offset_idx += str.name_len * char.sizeof;
                offset_idx += pad4(str.name_len * char.sizeof);
            }
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeKeyboardMapping
{
    ubyte keycode_count;
    KeyCode first_keycode;
    ubyte keysyms_per_keycode;
    KeySym[] keysyms;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.keysyms.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.keysyms.offsetof);

        assert ((this.keycode_count * this.keysyms_per_keycode) == this.keysyms.length);
        parts[2].iov_base = this.keysyms.ptr;
        parts[2].iov_len = this.keysyms.length * KeySym.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.keysyms.length * KeySym.sizeof);

        return parts;
    }
}


struct GetKeyboardMapping
{
    byte[1] _pad0;
    KeyCode first_keycode;
    ubyte count;

    struct Reply
    {
        ubyte keysyms_per_keycode;
		ushort length;
        byte[24] _pad0;
        KeySym[] keysyms;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.keysyms.offsetof] =
                        buf[offset_idx..offset_idx+this.keysyms.offsetof];
            offset_idx += this.keysyms.offsetof;

            this.keysyms = (cast(KeySym*)&buf[offset_idx])[0..this.length].dup;
            offset_idx += this.length * KeySym.sizeof;
            offset_idx += pad4(this.length * KeySym.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeKeyboardControl
{
    byte[1] _pad0;
    uint value_mask;
    uint[] value_list;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.value_list.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.value_list.offsetof);

        parts[2].iov_base = this.value_list.ptr;
        parts[2].iov_len = bitcount(this.value_mask) * uint.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.value_list.length);

        return parts;
    }
}


struct GetKeyboardControl
{

    struct Reply
    {
        ubyte global_auto_repeat;
        uint led_mask;
        ubyte key_click_percent;
        ubyte bell_percent;
        ushort bell_pitch;
        ushort bell_duration;
        byte[2] _pad0;
        ubyte[32] auto_repeats;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.auto_repeats.offsetof] =
                        buf[offset_idx..offset_idx+this.auto_repeats.offsetof];
            offset_idx += this.auto_repeats.offsetof;

            this.auto_repeats = (cast(ubyte*)&buf[offset_idx])[0..32].dup;
            offset_idx += 32 * ubyte.sizeof;
            offset_idx += pad4(32 * ubyte.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct Bell
{
    byte percent;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangePointerControl
{
    byte[1] _pad0;
    short acceleration_numerator;
    short acceleration_denominator;
    short threshold;
    ubyte do_acceleration;
    ubyte do_threshold;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetPointerControl
{

    struct Reply
    {
        byte[1] _pad0;
        ushort acceleration_numerator;
        ushort acceleration_denominator;
        ushort threshold;
        byte[18] _pad1;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetScreenSaver
{
    byte[1] _pad0;
    short timeout;
    short interval;
    ubyte prefer_blanking;
    ubyte allow_exposures;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct GetScreenSaver
{

    struct Reply
    {
        byte[1] _pad0;
        ushort timeout;
        ushort interval;
        ubyte prefer_blanking;
        ubyte allow_exposures;
        byte[18] _pad1;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct ChangeHosts
{
    ubyte mode;
    ubyte family;
    byte[1] _pad0;
    ushort address_len;
    char[] address;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.address.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.address.offsetof);

        assert (this.address_len == this.address.length);
        parts[2].iov_base = this.address.ptr;
        parts[2].iov_len = this.address.length * char.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.address.length * char.sizeof);

        return parts;
    }
}


struct ListHosts
{

    struct Reply
    {
        ubyte mode;
        ushort hosts_len;
        byte[22] _pad0;
        Host[] hosts;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.hosts.offsetof] =
                        buf[offset_idx..offset_idx+this.hosts.offsetof];
            offset_idx += this.hosts.offsetof;

            this.hosts.length = this.hosts_len;
            foreach (ref host; this.hosts)
            {
                auto host_buf = cast(ubyte*)&host;
                host_buf[0..host.address.offsetof] =
                            buf[offset_idx..offset_idx+host.address.offsetof];
                offset_idx += host.address.offsetof;

                host.address = (cast(ubyte*)&buf[offset_idx])[0..host.address_len].dup;
                offset_idx += host.address_len * ubyte.sizeof;
                offset_idx += pad4(host.address_len * ubyte.sizeof);
            }
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetAccessControl
{
    ubyte mode;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetCloseDownMode
{
    ubyte mode;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct KillClient
{
    byte[1] _pad0;
    uint resource;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct RotateProperties
{
    byte[1] _pad0;
    Window window;
    ushort atoms_len;
    short delta;
    Atom[] atoms;

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.atoms.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.atoms.offsetof);

        assert (this.atoms_len == this.atoms.length);
        parts[2].iov_base = this.atoms.ptr;
        parts[2].iov_len = this.atoms.length * Atom.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.atoms.length * Atom.sizeof);

        return parts;
    }
}


struct ForceScreenSaver
{
    ubyte mode;

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetPointerMapping
{
    ubyte map_len;
    ubyte[] map;

    struct Reply
    {
        ubyte status;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.map.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.map.offsetof);

        assert (this.map_len == this.map.length);
        parts[2].iov_base = this.map.ptr;
        parts[2].iov_len = this.map.length * ubyte.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.map.length * ubyte.sizeof);

        return parts;
    }
}


struct GetPointerMapping
{

    struct Reply
    {
        ubyte map_len;
        byte[24] _pad0;
        ubyte[] map;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.map.offsetof] =
                        buf[offset_idx..offset_idx+this.map.offsetof];
            offset_idx += this.map.offsetof;

            this.map = (cast(ubyte*)&buf[offset_idx])[0..this.map_len].dup;
            offset_idx += this.map_len * ubyte.sizeof;
            offset_idx += pad4(this.map_len * ubyte.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct SetModifierMapping
{
    ubyte keycodes_per_modifier;
    KeyCode[] keycodes;

    struct Reply
    {
        ubyte status;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.sizeof] = buf[offset_idx..offset_idx+this.sizeof];
        }
    }

    iovec[4] toIOVector()
    {
        iovec[4] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.keycodes.offsetof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.keycodes.offsetof);

        assert ((this.keycodes_per_modifier * 8) == this.keycodes.length);
        parts[2].iov_base = this.keycodes.ptr;
        parts[2].iov_len = this.keycodes.length * KeyCode.sizeof;

        parts[3].iov_base = null;
        parts[3].iov_len = pad4(this.keycodes.length * KeyCode.sizeof);

        return parts;
    }
}


struct GetModifierMapping
{

    struct Reply
    {
        ubyte keycodes_per_modifier;
        byte[24] _pad0;
        KeyCode[] keycodes;

        this(const ubyte[] buf)
        {
            int offset_idx = 0;
            auto this_buf = cast(ubyte*)&this;
            this_buf[0..this.keycodes.offsetof] =
                        buf[offset_idx..offset_idx+this.keycodes.offsetof];
            offset_idx += this.keycodes.offsetof;

            this.keycodes = (cast(KeyCode*)&buf[offset_idx])[0..(this.keycodes_per_modifier * 8)].dup;
            offset_idx += (this.keycodes_per_modifier * 8) * KeyCode.sizeof;
            offset_idx += pad4((this.keycodes_per_modifier * 8) * KeyCode.sizeof);
        }
    }

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


struct NoOperation
{

    iovec[2] toIOVector()
    {
        iovec[2] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.sizeof;

        // FIXME: padding needed?
        parts[1].iov_base = null;
        parts[1].iov_len = pad4(this.sizeof);

        return parts;
    }
}


/**
 * errorcopys
 */


/**
 * errors
 */


/**
 * events
 */

/**
 * eventcopies
 */
