/* this file is generated by xd/codegen.py */

module xd.xproto;

version (Posix)
{
	//import core.sys.posix.sys.uio: iovec;
}

import xd.util: iovec, pad4;


/**
 * typedefs
 */
typedef uint Window;
typedef uint PixMap;
typedef uint Cursor;
typedef uint Font;
typedef uint GContext;
typedef uint ColorMap;
typedef uint Atom;
typedef uint VisualID;
typedef uint Timestamp;
typedef uint KeySym;
typedef ubyte KeyCode;
typedef ubyte Button;


/**
 * structs
 */

struct Point
{
    short x;
    short y;
}

struct Rectangle
{
    short x;
    short y;
    ushort width;
    ushort height;
}

struct Arc
{
    short x;
    short y;
    ushort width;
    ushort height;
    short angle1;
    short angle2;
}

struct Format
{
    ubyte depth;
    ubyte bits_per_pixel;
    ubyte scanline_pad;
    byte[5] _pad0;
}

struct VisualType
{
    VisualID visual_id;
    ubyte klass;
    ubyte bits_per_rgb_value;
    ushort colormap_entries;
    uint red_mask;
    uint green_mask;
    uint blue_mask;
    byte[4] _pad0;
}

struct Depth
{
    ubyte depth;
    byte[1] _pad0;
    ushort visuals_len;
    byte[4] _pad1;
    VisualType[] visuals;
}

struct Screen
{
    Window root;
    ColorMap default_colormap;
    uint white_pixel;
    uint black_pixel;
    uint current_input_masks;
    ushort width_in_pixels;
    ushort height_in_pixels;
    ushort width_in_millimeters;
    ushort height_in_millimeters;
    ushort min_installed_maps;
    ushort max_installed_maps;
    VisualID root_visual;
    ubyte backing_stores;
    ubyte save_unders;
    ubyte root_depth;
    ubyte allowed_depths_len;
    Depth[] allowed_depths;
}

struct SetupRequest
{
    ubyte byte_order;
    byte[1] _pad0;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort authorization_protocol_name_len;
    ushort authorization_protocol_data_len;
    byte[2] _pad1;
    char[] authorization_protocol_name;
    char[] authorization_protocol_data;

    iovec[5] toIOVector()
    {
        byte[3] pad;
        iovec[5] parts;

        parts[0].iov_base = &this;
        parts[0].iov_len = this.authorization_protocol_name.offsetof;

        this.authorization_protocol_name_len = cast(typeof(this.authorization_protocol_name_len))this.authorization_protocol_name.length;
        parts[1].iov_base = this.authorization_protocol_name.ptr;
        parts[1].iov_len = this.authorization_protocol_name.length;

        parts[2].iov_base = pad.ptr;
        parts[2].iov_len = pad4(this.authorization_protocol_name.length);

        this.authorization_protocol_data_len = cast(typeof(this.authorization_protocol_data_len))this.authorization_protocol_data.length;
        parts[3].iov_base = this.authorization_protocol_data.ptr;
        parts[3].iov_len = this.authorization_protocol_data.length;

        parts[4].iov_base = pad.ptr;
        parts[4].iov_len = pad4(this.authorization_protocol_data.length);

        return parts;
    }
}

struct SetupFailed
{
    ubyte status;
    ubyte reason_len;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort length;
    char[] reason;
}

struct SetupAuthenticate
{
    ubyte status;
    byte[5] _pad0;
    ushort length;
    char[] reason;
}

struct Setup
{
    ubyte status;
    byte[1] _pad0;
    ushort protocol_major_version;
    ushort protocol_minor_version;
    ushort length;
    uint release_number;
    uint resource_id_base;
    uint resource_id_mask;
    uint motion_buffer_size;
    ushort vendor_len;
    ushort maximum_request_length;
    ubyte roots_len;
    ubyte pixmap_formats_len;
    ubyte image_byte_order;
    ubyte bitmap_format_bit_order;
    ubyte bitmap_format_scanline_unit;
    ubyte bitmap_format_scanline_pad;
    KeyCode min_keycode;
    KeyCode max_keycode;
    byte[4] _pad1;
    char[] vendor;
    Format[] pixmap_formats;
    Screen[] roots;

    this(const ubyte[] buf)
    {
        int offset_idx = 0;
        auto this_buf = cast(ubyte*)&this;
        this_buf[0..this.vendor.offsetof] =
                    buf[offset_idx..offset_idx+this.vendor.offsetof];
        offset_idx += this.vendor.offsetof;

        this.vendor = (cast(char*)&buf[offset_idx])[0..this.vendor_len].dup;
        offset_idx += this.vendor_len * char.sizeof;
        offset_idx += pad4(this.vendor_len * char.sizeof);

        this.pixmap_formats = (cast(Format*)&buf[offset_idx])[0..this.pixmap_formats_len].dup;
        offset_idx += this.pixmap_formats_len * Format.sizeof;
        offset_idx += pad4(this.pixmap_formats_len * Format.sizeof);

        this.roots.length = this.roots_len;
        foreach (ref screen; this.roots)
        {
            auto screen_buf = cast(ubyte*)&screen;
            screen_buf[0..screen.allowed_depths.offsetof] =
                        buf[offset_idx..offset_idx+screen.allowed_depths.offsetof];
            offset_idx += screen.allowed_depths.offsetof;

            screen.allowed_depths.length = screen.allowed_depths_len;
            foreach (ref depth; screen.allowed_depths)
            {
                auto depth_buf = cast(ubyte*)&depth;
                depth_buf[0..depth.visuals.offsetof] =
                            buf[offset_idx..offset_idx+depth.visuals.offsetof];
                offset_idx += depth.visuals.offsetof;

                depth.visuals = (cast(VisualType*)&buf[offset_idx])[0..depth.visuals_len].dup;
                offset_idx += depth.visuals_len * VisualType.sizeof;
                offset_idx += pad4(depth.visuals_len * VisualType.sizeof);
            }
        }
    }
}

struct CreateWindow
{
    ubyte depth;
    Window wid;
    Window parent;
    short x;
    short y;
    ushort width;
    ushort height;
    ushort border_width;
    ushort klass;
    VisualID visual;
    CARD32 value_mask;
}

struct ChangeWindowAttributes
{
    byte[1] _pad0;
    Window window;
    CARD32 value_mask;
}

struct GetWindowAttributes
{
    byte[1] _pad0;
    Window window;
    struct Reply
    {
        ubyte backing_store;
        VisualID visual;
        ushort klass;
        ubyte bit_gravity;
        ubyte win_gravity;
        uint backing_planes;
        uint backing_pixel;
        ubyte save_under;
        ubyte map_is_installed;
        ubyte map_state;
        ubyte override_redirect;
        ColorMap colormap;
        uint all_event_masks;
        uint your_event_mask;
        ushort do_not_propagate_mask;
        byte[2] _pad0;
    }
}

struct DestroyWindow
{
    byte[1] _pad0;
    Window window;
}

struct DestroySubwindows
{
    byte[1] _pad0;
    Window window;
}

struct ChangeSaveSet
{
    ubyte mode;
    Window window;
}

struct ReparentWindow
{
    byte[1] _pad0;
    Window window;
    Window parent;
    short x;
    short y;
}

struct MapWindow
{
    byte[1] _pad0;
    Window window;
}

struct MapSubwindows
{
    byte[1] _pad0;
    Window window;
}

struct UnmapWindow
{
    byte[1] _pad0;
    Window window;
}

struct UnmapSubwindows
{
    byte[1] _pad0;
    Window window;
}

struct ConfigureWindow
{
    byte[1] _pad0;
    Window window;
    CARD16 value_mask;
}

struct CirculateWindow
{
    ubyte direction;
    Window window;
}

struct GetGeometry
{
    byte[1] _pad0;
    Drawable drawable;
    struct Reply
    {
        ubyte depth;
        Window root;
        short x;
        short y;
        ushort width;
        ushort height;
        ushort border_width;
        byte[2] _pad0;
    }
}

struct QueryTree
{
    byte[1] _pad0;
    Window window;
    struct Reply
    {
        byte[1] _pad0;
        Window root;
        Window parent;
        ushort children_len;
        byte[14] _pad1;
        Window[] children;
    }
}

struct InternAtom
{
    ubyte only_if_exists;
    ushort name_len;
    byte[2] _pad0;
    char[] name;
    struct Reply
    {
        byte[1] _pad0;
        Atom atom;
    }
}

struct GetAtomName
{
    byte[1] _pad0;
    Atom atom;
    struct Reply
    {
        byte[1] _pad0;
        ushort name_len;
        byte[22] _pad1;
        char[] name;
    }
}

struct ChangeProperty
{
    ubyte mode;
    Window window;
    Atom property;
    Atom type;
    ubyte format;
    byte[3] _pad0;
    uint data_len;
    void[] data;
}

struct DeleteProperty
{
    byte[1] _pad0;
    Window window;
    Atom property;
}

struct GetProperty
{
    ubyte delete;
    Window window;
    Atom property;
    Atom type;
    uint long_offset;
    uint long_length;
    struct Reply
    {
        ubyte format;
        Atom type;
        uint bytes_after;
        uint value_len;
        byte[12] _pad0;
        void[] value;
    }
}

struct ListProperties
{
    byte[1] _pad0;
    Window window;
    struct Reply
    {
        byte[1] _pad0;
        ushort atoms_len;
        byte[22] _pad1;
        Atom[] atoms;
    }
}

struct SetSelectionOwner
{
    byte[1] _pad0;
    Window owner;
    Atom selection;
    Timestamp time;
}

struct GetSelectionOwner
{
    byte[1] _pad0;
    Atom selection;
    struct Reply
    {
        byte[1] _pad0;
        Window owner;
    }
}

struct ConvertSelection
{
    byte[1] _pad0;
    Window requestor;
    Atom selection;
    Atom target;
    Atom property;
    Timestamp time;
}

struct SendEvent
{
    ubyte propagate;
    Window destination;
    uint event_mask;
    char[32] event;
}

struct GrabPointer
{
    ubyte owner_events;
    Window grab_window;
    ushort event_mask;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    Window confine_to;
    Cursor cursor;
    Timestamp time;
    struct Reply
    {
        ubyte status;
    }
}

struct UngrabPointer
{
    byte[1] _pad0;
    Timestamp time;
}

struct GrabButton
{
    ubyte owner_events;
    Window grab_window;
    ushort event_mask;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    Window confine_to;
    Cursor cursor;
    ubyte button;
    byte[1] _pad0;
    ushort modifiers;
}

struct UngrabButton
{
    ubyte button;
    Window grab_window;
    ushort modifiers;
    byte[2] _pad0;
}

struct ChangeActivePointerGrab
{
    byte[1] _pad0;
    Cursor cursor;
    Timestamp time;
    ushort event_mask;
    byte[2] _pad1;
}

struct GrabKeyboard
{
    ubyte owner_events;
    Window grab_window;
    Timestamp time;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    byte[2] _pad0;
    struct Reply
    {
        ubyte status;
    }
}

struct UngrabKeyboard
{
    byte[1] _pad0;
    Timestamp time;
}

struct GrabKey
{
    ubyte owner_events;
    Window grab_window;
    ushort modifiers;
    KeyCode key;
    ubyte pointer_mode;
    ubyte keyboard_mode;
    byte[3] _pad0;
}

struct UngrabKey
{
    KeyCode key;
    Window grab_window;
    ushort modifiers;
    byte[2] _pad0;
}

struct AllowEvents
{
    ubyte mode;
    Timestamp time;
}

struct GrabServer
{
}

struct UngrabServer
{
}

struct QueryPointer
{
    byte[1] _pad0;
    Window window;
    struct Reply
    {
        ubyte same_screen;
        Window root;
        Window child;
        short root_x;
        short root_y;
        short win_x;
        short win_y;
        ushort mask;
        byte[2] _pad0;
    }
}

struct TimeCoord
{
    Timestamp time;
    short x;
    short y;
}

struct GetMotionEvents
{
    byte[1] _pad0;
    Window window;
    Timestamp start;
    Timestamp stop;
    struct Reply
    {
        byte[1] _pad0;
        uint events_len;
        byte[20] _pad1;
        TimeCoord[] events;
    }
}

struct TranslateCoordinates
{
    byte[1] _pad0;
    Window src_window;
    Window dst_window;
    short src_x;
    short src_y;
    struct Reply
    {
        ubyte same_screen;
        Window child;
        ushort dst_x;
        ushort dst_y;
    }
}

struct WarpPointer
{
    byte[1] _pad0;
    Window src_window;
    Window dst_window;
    short src_x;
    short src_y;
    ushort src_width;
    ushort src_height;
    short dst_x;
    short dst_y;
}

struct SetInputFocus
{
    ubyte revert_to;
    Window focus;
    Timestamp time;
}

struct GetInputFocus
{
    struct Reply
    {
        ubyte revert_to;
        Window focus;
    }
}

struct QueryKeymap
{
    struct Reply
    {
        byte[1] _pad0;
        ubyte[32] keys;
    }
}

struct OpenFont
{
    byte[1] _pad0;
    Font fid;
    ushort name_len;
    byte[2] _pad1;
    char[] name;
}

struct CloseFont
{
    byte[1] _pad0;
    Font font;
}

struct FontProp
{
    Atom name;
    uint value;
}

struct CharInfo
{
    short left_side_bearing;
    short right_side_bearing;
    short character_width;
    short ascent;
    short descent;
    ushort attributes;
}

struct QueryFont
{
    byte[1] _pad0;
    Fontable font;
    struct Reply
    {
        byte[1] _pad0;
        CharInfo min_bounds;
        byte[4] _pad1;
        CharInfo max_bounds;
        byte[4] _pad2;
        ushort min_char_or_byte2;
        ushort max_char_or_byte2;
        ushort default_char;
        ushort properties_len;
        ubyte draw_direction;
        ubyte min_byte1;
        ubyte max_byte1;
        ubyte all_chars_exist;
        short font_ascent;
        short font_descent;
        uint char_infos_len;
        FontProp[] properties;
        CharInfo[] char_infos;
    }
}

struct QueryTextExtents
{
    BOOL odd_length;
    Fontable font;
    wchar[] string;
    struct Reply
    {
        ubyte draw_direction;
        short font_ascent;
        short font_descent;
        short overall_ascent;
        short overall_descent;
        int overall_width;
        int overall_left;
        int overall_right;
    }
}

struct Str
{
    ubyte name_len;
    char[] name;
}

struct ListFonts
{
    byte[1] _pad0;
    ushort max_names;
    ushort pattern_len;
    char[] pattern;
    struct Reply
    {
        byte[1] _pad0;
        ushort names_len;
        byte[22] _pad1;
        Str[] names;
    }
}

struct ListFontsWithInfo
{
    byte[1] _pad0;
    ushort max_names;
    ushort pattern_len;
    char[] pattern;
    struct Reply
    {
        ubyte name_len;
        CharInfo min_bounds;
        byte[4] _pad0;
        CharInfo max_bounds;
        byte[4] _pad1;
        ushort min_char_or_byte2;
        ushort max_char_or_byte2;
        ushort default_char;
        ushort properties_len;
        ubyte draw_direction;
        ubyte min_byte1;
        ubyte max_byte1;
        ubyte all_chars_exist;
        short font_ascent;
        short font_descent;
        uint replies_hint;
        FontProp[] properties;
        char[] name;
    }
}

struct SetFontPath
{
    byte[1] _pad0;
    ushort font_qty;
    char[] path;
}

struct GetFontPath
{
    struct Reply
    {
        byte[1] _pad0;
        ushort path_len;
        byte[22] _pad1;
        Str[] path;
    }
}

struct CreatePixmap
{
    ubyte depth;
    PixMap pid;
    Drawable drawable;
    ushort width;
    ushort height;
}

struct FreePixmap
{
    byte[1] _pad0;
    PixMap pixmap;
}

struct CreateGC
{
    byte[1] _pad0;
    GContext cid;
    Drawable drawable;
    CARD32 value_mask;
}

struct ChangeGC
{
    byte[1] _pad0;
    GContext gc;
    CARD32 value_mask;
}

struct CopyGC
{
    byte[1] _pad0;
    GContext src_gc;
    GContext dst_gc;
    uint value_mask;
}

struct SetDashes
{
    byte[1] _pad0;
    GContext gc;
    ushort dash_offset;
    ushort dashes_len;
    ubyte[] dashes;
}

struct SetClipRectangles
{
    ubyte ordering;
    GContext gc;
    short clip_x_origin;
    short clip_y_origin;
    Rectangle[] rectangles;
}

struct FreeGC
{
    byte[1] _pad0;
    GContext gc;
}

struct ClearArea
{
    ubyte exposures;
    Window window;
    short x;
    short y;
    ushort width;
    ushort height;
}

struct CopyArea
{
    byte[1] _pad0;
    Drawable src_drawable;
    Drawable dst_drawable;
    GContext gc;
    short src_x;
    short src_y;
    short dst_x;
    short dst_y;
    ushort width;
    ushort height;
}

struct CopyPlane
{
    byte[1] _pad0;
    Drawable src_drawable;
    Drawable dst_drawable;
    GContext gc;
    short src_x;
    short src_y;
    short dst_x;
    short dst_y;
    ushort width;
    ushort height;
    uint bit_plane;
}

struct PolyPoint
{
    ubyte coordinate_mode;
    Drawable drawable;
    GContext gc;
    Point[] points;
}

struct PolyLine
{
    ubyte coordinate_mode;
    Drawable drawable;
    GContext gc;
    Point[] points;
}

struct Segment
{
    short x1;
    short y1;
    short x2;
    short y2;
}

struct PolySegment
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Segment[] segments;
}

struct PolyRectangle
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Rectangle[] rectangles;
}

struct PolyArc
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Arc[] arcs;
}

struct FillPoly
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    ubyte shape;
    ubyte coordinate_mode;
    byte[2] _pad1;
    Point[] points;
}

struct PolyFillRectangle
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Rectangle[] rectangles;
}

struct PolyFillArc
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    Arc[] arcs;
}

struct PutImage
{
    ubyte format;
    Drawable drawable;
    GContext gc;
    ushort width;
    ushort height;
    short dst_x;
    short dst_y;
    ubyte left_pad;
    ubyte depth;
    byte[2] _pad0;
    ubyte[] data;
}

struct GetImage
{
    ubyte format;
    Drawable drawable;
    short x;
    short y;
    ushort width;
    ushort height;
    uint plane_mask;
    struct Reply
    {
        ubyte depth;
        VisualID visual;
        byte[20] _pad0;
        ubyte[] data;
    }
}

struct PolyText8
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    ubyte[] items;
}

struct PolyText16
{
    byte[1] _pad0;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    ubyte[] items;
}

struct ImageText8
{
    ubyte string_len;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    char[] string;
}

struct ImageText16
{
    ubyte string_len;
    Drawable drawable;
    GContext gc;
    short x;
    short y;
    wchar[] string;
}

struct CreateColormap
{
    ubyte alloc;
    ColorMap mid;
    Window window;
    VisualID visual;
}

struct FreeColormap
{
    byte[1] _pad0;
    ColorMap cmap;
}

struct CopyColormapAndFree
{
    byte[1] _pad0;
    ColorMap mid;
    ColorMap src_cmap;
}

struct InstallColormap
{
    byte[1] _pad0;
    ColorMap cmap;
}

struct UninstallColormap
{
    byte[1] _pad0;
    ColorMap cmap;
}

struct ListInstalledColormaps
{
    byte[1] _pad0;
    Window window;
    struct Reply
    {
        byte[1] _pad0;
        ushort cmaps_len;
        byte[22] _pad1;
        ColorMap[] cmaps;
    }
}

struct AllocColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort red;
    ushort green;
    ushort blue;
    byte[2] _pad1;
    struct Reply
    {
        byte[1] _pad0;
        ushort red;
        ushort green;
        ushort blue;
        byte[2] _pad1;
        uint pixel;
    }
}

struct AllocNamedColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort name_len;
    byte[2] _pad1;
    char[] name;
    struct Reply
    {
        byte[1] _pad0;
        uint pixel;
        ushort exact_red;
        ushort exact_green;
        ushort exact_blue;
        ushort visual_red;
        ushort visual_green;
        ushort visual_blue;
    }
}

struct AllocColorCells
{
    ubyte contiguous;
    ColorMap cmap;
    ushort colors;
    ushort planes;
    struct Reply
    {
        byte[1] _pad0;
        ushort pixels_len;
        ushort masks_len;
        byte[20] _pad1;
        uint[] pixels;
        uint[] masks;
    }
}

struct AllocColorPlanes
{
    ubyte contiguous;
    ColorMap cmap;
    ushort colors;
    ushort reds;
    ushort greens;
    ushort blues;
    struct Reply
    {
        byte[1] _pad0;
        ushort pixels_len;
        byte[2] _pad1;
        uint red_mask;
        uint green_mask;
        uint blue_mask;
        byte[8] _pad2;
        uint[] pixels;
    }
}

struct FreeColors
{
    byte[1] _pad0;
    ColorMap cmap;
    uint plane_mask;
    uint[] pixels;
}

struct ColorItem
{
    uint pixel;
    ushort red;
    ushort green;
    ushort blue;
    ubyte flags;
    byte[1] _pad0;
}

struct StoreColors
{
    byte[1] _pad0;
    ColorMap cmap;
    ColorItem[] items;
}

struct StoreNamedColor
{
    ubyte flags;
    ColorMap cmap;
    uint pixel;
    ushort name_len;
    byte[2] _pad0;
    char[] name;
}

struct RGB
{
    ushort red;
    ushort green;
    ushort blue;
    byte[2] _pad0;
}

struct QueryColors
{
    byte[1] _pad0;
    ColorMap cmap;
    uint[] pixels;
    struct Reply
    {
        byte[1] _pad0;
        ushort colors_len;
        byte[22] _pad1;
        RGB[] colors;
    }
}

struct LookupColor
{
    byte[1] _pad0;
    ColorMap cmap;
    ushort name_len;
    byte[2] _pad1;
    char[] name;
    struct Reply
    {
        byte[1] _pad0;
        ushort exact_red;
        ushort exact_green;
        ushort exact_blue;
        ushort visual_red;
        ushort visual_green;
        ushort visual_blue;
    }
}

struct CreateCursor
{
    byte[1] _pad0;
    Cursor cid;
    PixMap source;
    PixMap mask;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;
    ushort x;
    ushort y;
}

struct CreateGlyphCursor
{
    byte[1] _pad0;
    Cursor cid;
    Font source_font;
    Font mask_font;
    ushort source_char;
    ushort mask_char;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;
}

struct FreeCursor
{
    byte[1] _pad0;
    Cursor cursor;
}

struct RecolorCursor
{
    byte[1] _pad0;
    Cursor cursor;
    ushort fore_red;
    ushort fore_green;
    ushort fore_blue;
    ushort back_red;
    ushort back_green;
    ushort back_blue;
}

struct QueryBestSize
{
    ubyte klass;
    Drawable drawable;
    ushort width;
    ushort height;
    struct Reply
    {
        byte[1] _pad0;
        ushort width;
        ushort height;
    }
}

struct QueryExtension
{
    byte[1] _pad0;
    ushort name_len;
    byte[2] _pad1;
    char[] name;
    struct Reply
    {
        byte[1] _pad0;
        ubyte present;
        ubyte major_opcode;
        ubyte first_event;
        ubyte first_error;
    }
}

struct ListExtensions
{
    struct Reply
    {
        ubyte names_len;
        byte[24] _pad0;
        Str[] names;
    }
}

struct ChangeKeyboardMapping
{
    ubyte keycode_count;
    KeyCode first_keycode;
    ubyte keysyms_per_keycode;
    KeySym[] keysyms;
}

struct GetKeyboardMapping
{
    byte[1] _pad0;
    KeyCode first_keycode;
    ubyte count;
    struct Reply
    {
        ubyte keysyms_per_keycode;
        byte[24] _pad0;
        KeySym[] keysyms;
    }
}

struct ChangeKeyboardControl
{
    byte[1] _pad0;
    CARD32 value_mask;
}

struct GetKeyboardControl
{
    struct Reply
    {
        ubyte global_auto_repeat;
        uint led_mask;
        ubyte key_click_percent;
        ubyte bell_percent;
        ushort bell_pitch;
        ushort bell_duration;
        byte[2] _pad0;
        ubyte[32] auto_repeats;
    }
}

struct Bell
{
    byte percent;
}

struct ChangePointerControl
{
    byte[1] _pad0;
    short acceleration_numerator;
    short acceleration_denominator;
    short threshold;
    ubyte do_acceleration;
    ubyte do_threshold;
}

struct GetPointerControl
{
    struct Reply
    {
        byte[1] _pad0;
        ushort acceleration_numerator;
        ushort acceleration_denominator;
        ushort threshold;
        byte[18] _pad1;
    }
}

struct SetScreenSaver
{
    byte[1] _pad0;
    short timeout;
    short interval;
    ubyte prefer_blanking;
    ubyte allow_exposures;
}

struct GetScreenSaver
{
    struct Reply
    {
        byte[1] _pad0;
        ushort timeout;
        ushort interval;
        ubyte prefer_blanking;
        ubyte allow_exposures;
        byte[18] _pad1;
    }
}

struct ChangeHosts
{
    ubyte mode;
    ubyte family;
    byte[1] _pad0;
    ushort address_len;
    char[] address;
}

struct Host
{
    ubyte family;
    byte[1] _pad0;
    ushort address_len;
    ubyte[] address;
}

struct ListHosts
{
    struct Reply
    {
        ubyte mode;
        ushort hosts_len;
        byte[22] _pad0;
        Host[] hosts;
    }
}

struct SetAccessControl
{
    ubyte mode;
}

struct SetCloseDownMode
{
    ubyte mode;
}

struct KillClient
{
    byte[1] _pad0;
    uint resource;
}

struct RotateProperties
{
    byte[1] _pad0;
    Window window;
    ushort atoms_len;
    short delta;
    Atom[] atoms;
}

struct ForceScreenSaver
{
    ubyte mode;
}

struct SetPointerMapping
{
    ubyte map_len;
    ubyte[] map;
    struct Reply
    {
        ubyte status;
    }
}

struct GetPointerMapping
{
    struct Reply
    {
        ubyte map_len;
        byte[24] _pad0;
        ubyte[] map;
    }
}

struct SetModifierMapping
{
    ubyte keycodes_per_modifier;
    KeyCode[] keycodes;
    struct Reply
    {
        ubyte status;
    }
}

struct GetModifierMapping
{
    struct Reply
    {
        ubyte keycodes_per_modifier;
        byte[24] _pad0;
        KeyCode[] keycodes;
    }
}

struct NoOperation
{
}


/**
 *unions
 */


/**
 * enums
 */

enum VisualClass
{
    StaticGray = 0,
    GrayScale = 1,
    StaticColor = 2,
    PseudoColor = 3,
    TrueColor = 4,
    DirectColor = 5,
}

enum EventMask
{
    NoEvent = 0,
    KeyPress = 0,
    KeyRelease = 1,
    ButtonPress = 2,
    ButtonRelease = 3,
    EnterWindow = 4,
    LeaveWindow = 5,
    PointerMotion = 6,
    PointerMotionHint = 7,
    Button1Motion = 8,
    Button2Motion = 9,
    Button3Motion = 10,
    Button4Motion = 11,
    Button5Motion = 12,
    ButtonMotion = 13,
    KeymapState = 14,
    Exposure = 15,
    VisibilityChange = 16,
    StructureNotify = 17,
    ResizeRedirect = 18,
    SubstructureNotify = 19,
    SubstructureRedirect = 20,
    FocusChange = 21,
    PropertyChange = 22,
    ColorMapChange = 23,
    OwnerGrabButton = 24,
}

enum BackingStore
{
    NotUseful = 0,
    WhenMapped = 1,
    Always = 2,
}

enum ImageOrder
{
    LSBFirst = 0,
    MSBFirst = 1,
}

enum ModMask
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    _1 = 3,
    _2 = 4,
    _3 = 5,
    _4 = 6,
    _5 = 7,
    Any = 15,
}

enum KeyButMask
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    Mod1 = 3,
    Mod2 = 4,
    Mod3 = 5,
    Mod4 = 6,
    Mod5 = 7,
    Button1 = 8,
    Button2 = 9,
    Button3 = 10,
    Button4 = 11,
    Button5 = 12,
}

enum Window
{
    None = 0,
}

enum ButtonMask
{
    _1 = 8,
    _2 = 9,
    _3 = 10,
    _4 = 11,
    _5 = 12,
    Any = 15,
}

enum Motion
{
    Normal = 0,
    Hint = 1,
}

enum NotifyDetail
{
    Ancestor = 0,
    Virtual = 1,
    Inferior = 2,
    Nonlinear = 3,
    NonlinearVirtual = 4,
    Pointer = 5,
    PointerRoot = 6,
    None = 7,
}

enum NotifyMode
{
    Normal = 0,
    Grab = 1,
    Ungrab = 2,
    WhileGrabbed = 3,
}

enum Visibility
{
    Unobscured = 0,
    PartiallyObscured = 1,
    FullyObscured = 2,
}

enum Place
{
    OnTop = 0,
    OnBottom = 1,
}

enum Property
{
    NewValue = 0,
    Delete = 1,
}

enum Time
{
    CurrentTime = 0,
}

enum Atom
{
    None = 0,
}

enum ColormapState
{
    Uninstalled = 0,
    Installed = 1,
}

enum Colormap
{
    None = 0,
}

enum Mapping
{
    Modifier = 0,
    Keyboard = 1,
    Pointer = 2,
}

enum WindowClass
{
    CopyFromParent = 0,
    InputOutput = 1,
    InputOnly = 2,
}

enum CW
{
    BackPixmap = 0,
    BackPixel = 1,
    BorderPixmap = 2,
    BorderPixel = 3,
    BitGravity = 4,
    WinGravity = 5,
    BackingStore = 6,
    BackingPlanes = 7,
    BackingPixel = 8,
    OverrideRedirect = 9,
    SaveUnder = 10,
    EventMask = 11,
    DontPropagate = 12,
    Colormap = 13,
    Cursor = 14,
}

enum BackPixmap
{
    None = 0,
    ParentRelative = 1,
}

enum Gravity
{
    BitForget = 0,
    WinUnmap = 0,
    NorthWest = 1,
    North = 2,
    NorthEast = 3,
    West = 4,
    Center = 5,
    East = 6,
    SouthWest = 7,
    South = 8,
    SouthEast = 9,
    Static = 10,
}

enum MapState
{
    Unmapped = 0,
    Unviewable = 1,
    Viewable = 2,
}

enum SetMode
{
    Insert = 0,
    Delete = 1,
}

enum ConfigWindow
{
    X = 0,
    Y = 1,
    Width = 2,
    Height = 3,
    BorderWidth = 4,
    Sibling = 5,
    StackMode = 6,
}

enum StackMode
{
    Above = 0,
    Below = 1,
    TopIf = 2,
    BottomIf = 3,
    Opposite = 4,
}

enum Circulate
{
    RaiseLowest = 0,
    LowerHighest = 1,
}

enum PropMode
{
    Replace = 0,
    Prepend = 1,
    Append = 2,
}

enum GetPropertyType
{
    Any = 0,
}

enum SendEventDest
{
    PointerWindow = 0,
    ItemFocus = 1,
}

enum GrabMode
{
    Sync = 0,
    Async = 1,
}

enum GrabStatus
{
    Success = 0,
    AlreadyGrabbed = 1,
    InvalidTime = 2,
    NotViewable = 3,
    Frozen = 4,
}

enum Cursor
{
    None = 0,
}

enum ButtonIndex
{
    Any = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

enum Grab
{
    Any = 0,
}

enum Allow
{
    AsyncPointer = 0,
    SyncPointer = 1,
    ReplayPointer = 2,
    AsyncKeyboard = 3,
    SyncKeyboard = 4,
    ReplayKeyboard = 5,
    AsyncBoth = 6,
    SyncBoth = 7,
}

enum InputFocus
{
    None = 0,
    PointerRoot = 1,
    Parent = 2,
    FollowKeyboard = 3,
}

enum FontDraw
{
    LeftToRight = 0,
    RightToLeft = 1,
}

enum GC
{
    Function = 0,
    PlaneMask = 1,
    Foreground = 2,
    Background = 3,
    LineWidth = 4,
    LineStyle = 5,
    CapStyle = 6,
    JoinStyle = 7,
    FillStyle = 8,
    FillRule = 9,
    Tile = 10,
    Stipple = 11,
    TileStippleOriginX = 12,
    TileStippleOriginY = 13,
    Font = 14,
    SubwindowMode = 15,
    GraphicsExposures = 16,
    ClipOriginX = 17,
    ClipOriginY = 18,
    ClipMask = 19,
    DashOffset = 20,
    DashList = 21,
    ArcMode = 22,
}

enum GX
{
    clear = 0,
    and = 1,
    andReverse = 2,
    copy = 3,
    andInverted = 4,
    noop = 5,
    xor = 6,
    or = 7,
    nor = 8,
    equiv = 9,
    invert = 10,
    orReverse = 11,
    copyInverted = 12,
    orInverted = 13,
    nand = 14,
    set = 15,
}

enum LineStyle
{
    Solid = 0,
    OnOffDash = 1,
    DoubleDash = 2,
}

enum CapStyle
{
    NotLast = 0,
    Butt = 1,
    Round = 2,
    Projecting = 3,
}

enum JoinStyle
{
    Miter = 0,
    Round = 1,
    Bevel = 2,
}

enum FillStyle
{
    Solid = 0,
    Tiled = 1,
    Stippled = 2,
    OpaqueStippled = 3,
}

enum FillRule
{
    EvenOdd = 0,
    Winding = 1,
}

enum SubwindowMode
{
    ClipByChildren = 0,
    IncludeInferiors = 1,
}

enum ArcMode
{
    Chord = 0,
    PieSlice = 1,
}

enum ClipOrdering
{
    Unsorted = 0,
    YSorted = 1,
    YXSorted = 2,
    YXBanded = 3,
}

enum CoordMode
{
    Origin = 0,
    Previous = 1,
}

enum PolyShape
{
    Complex = 0,
    Nonconvex = 1,
    Convex = 2,
}

enum ImageFormat
{
    XYBitmap = 0,
    XYPixmap = 1,
    ZPixmap = 2,
}

enum ColormapAlloc
{
    None = 0,
    All = 1,
}

enum ColorFlag
{
    Red = 0,
    Green = 1,
    Blue = 2,
}

enum Pixmap
{
    None = 0,
}

enum Font
{
    None = 0,
}

enum QueryShapeOf
{
    LargestCursor = 0,
    FastestTile = 1,
    FastestStipple = 2,
}

enum Kb
{
    KeyClickPercent = 0,
    BellPercent = 1,
    BellPitch = 2,
    BellDuration = 3,
    Led = 4,
    LedMode = 5,
    Key = 6,
    AutoRepeatMode = 7,
}

enum LedMode
{
    Off = 0,
    On = 1,
}

enum AutoRepeatMode
{
    Off = 0,
    On = 1,
    Default = 2,
}

enum Blanking
{
    NotPreferred = 0,
    Preferred = 1,
    Default = 2,
}

enum Exposures
{
    NotAllowed = 0,
    Allowed = 1,
    Default = 2,
}

enum HostMode
{
    Insert = 0,
    Delete = 1,
}

enum Family
{
    Internet = 0,
    DECnet = 1,
    Chaos = 2,
    ServerInterpreted = 5,
    Internet6 = 6,
}

enum AccessControl
{
    Disable = 0,
    Enable = 1,
}

enum CloseDown
{
    DestroyAll = 0,
    RetainPermanent = 1,
    RetainTemporary = 2,
}

enum Kill
{
    AllTemporary = 0,
}

enum ScreenSaver
{
    Reset = 0,
    Active = 1,
}

enum MappingStatus
{
    Success = 0,
    Busy = 1,
    Failure = 2,
}

enum MapIndex
{
    Shift = 0,
    Lock = 1,
    Control = 2,
    _1 = 3,
    _2 = 4,
    _3 = 5,
    _4 = 6,
    _5 = 7,
}


/**
 * requests
 */


/**
 * errorcopys
 */


/**
 * xidunion
 */


/**
 * errors
 */


/**
 * events
 */

/**
 * eventcopies
 */
